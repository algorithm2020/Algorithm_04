# 이진탐색트리란
http://ejklike.github.io/2018/01/09/traversing-a-binary-tree-1.html
https://www.youtube.com/watch?v=xxADG17SveY

* 루트노드, 왼쪽노드(루트노드값보다 작음), 오른쪽노드(루트노드값보다 큼)
* 이진탐색트리 구조로 탐색, 삽입, 삭제 알고리즘을 구현한다.
* 중복값이 없어야 한다.
* 정렬된 데이터의 경우 트리가 한쪽으로 치우쳐서 비효율적임.

```{python}
class Node(object):
    def __init__(self, data):
        self.data = data
        self.left = self.right = None
        
class BinarySearchTree(object):
    def __init__(self):
        self.root = None
        
    def insert(self, key):
      ...
    
    def find(self, key):
      ...
      
    def delete(self, key):
      ...
```

## (1) 삽입
* 새로 추가할 값과 현재 노드값을 비교한다.
* 작으면 왼쪽트리로 이동, 크면 오른쪽 트리로 이동한다.
* 자식 노드가 없을 때 삽입한다.

```{python}
def insert(self, data):
    self.root = self._insert_value(self.root, data)
    return self.root is not None

def _insert_value(self, node, data):
    # 맨처음 루트노드거나 리프노드인 경우
    if node is None:
        # 노드를 생성해서 리턴함 (삽입!)
        node = Node(data)
        return node

    else:
        if data < node.data:
            node.left = self._insert_value(node.left, data)
        elif data > node.data:
            node.right = self._insert_value(node.right, data)
            
    return node
```

## (2) 탐색
* 탐색할 값과 현재 노드값을 비교한다.
* 작으면 왼쪽탐색, 크면 오른쪽을 탐색한다.

```{python}
def find(self, key):
    return self._find_value(self.root, key)

def _find_value(self, root, key):
    # 찾은 경우
    ## 리프노드에 왔을 때 (더 찾을 녀석들이 없음) true? false?
    ## 중간에 찾고자 하는 값을 만났을 때 (True 반환)
    if root is None or root.data == key:
        return root is not None

    # 아직 못 찾은 경우 (찾으려는 값이 root 노드값보다 작을 때), 왼쪽 트리 탐색 
    elif key < root.data:
        return self._find_value(root.left, key)
    # 아직 못 찾은 경우 (찾으려는 값이 root 노드값보다 클 때), 오른쪽 트리 탐색 
    else:
        return self._find_value(root.right, key)
```

## (3) 삭제
* 삭제하려는 노드의 자식노드가 많으면 헬


# 순회방법
https://www.youtube.com/watch?v=QN1rZYX6QaA

## (1) preorder 전위순회 (root - left - right)
## (2) postorder 후위순회 (left - right - root)
## (3) inorder 중위순회 (left - root - right)
